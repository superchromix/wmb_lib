;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   wmb_hash_display_form.pro
;
;   Form widget to get a single numeric value from the user.
;
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc



;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   Event handler
;
;   Note that events generated by widgets other than the OK or Cancel buttons
;   are being ignored due to the case statement.
;
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


pro wmb_hash_display_form_event, event

    compile_opt idl2, strictarrsubs

    formcancel = 0
    formclose = 0

    ; get state information
    widget_control, event.top, get_uvalue=locinfoptr
    locinfo = *locinfoptr

    ; retrieve information from the info pointer
    wid_def_hash = locinfo.wid_def_hash
    layout_list = locinfo.layout_list
    input_hash = locinfo.input_hash
    output_hash = locinfo.output_hash
    labelfont = locinfo.label_font
    fieldfont = locinfo.field_font
    rowframe = locinfo.row_frame
    rowyspace = locinfo.row_yspace

    ; identify widget which caused the event
    widget_uname = widget_info(event.id, /UNAME)

    event_struct_name = tag_names(event, /STRUCTURE_NAME)

    if event_struct_name eq 'FSC_INPUTFIELD_EVENT' then begin
    
        ; if the event came from an fsc_inputfield, then we need to use
        ; the object reference to talk to it
        
        objref = event.ObjRef
        objref -> GetProperty, Name = widget_uname
        
    endif

    ; if this event originated from one of the I/O widgets, handle it here
    
    if wid_def_hash.Haskey(widget_uname) then begin
    
        ; make sure the input and output hash also contain this key
        
        if ~input_hash.Haskey(widget_uname) then $
                                    message, 'Unmatched widget name'
                                    
        if ~output_hash.Haskey(widget_uname) then $
                                    message, 'Unmatched widget name'
                
        wid = event.id
        widdef = wid_def_hash[widget_uname]
        inputdat = input_hash[widget_uname]
        outputdat = output_hash[widget_uname]
                                    
        ; what kind of widget is this?
        
        wtype = widdef['type']
        
        case strlowcase(wtype) of
        
            'numeric': begin
            
                if N_elements(objref -> Get_Value()) ne 0 then begin
                
                    output_hash[widget_uname] = objref -> Get_Value()
                
                endif
            
            end
            
            'multinumeric': begin
            
                if N_elements(objref -> Get_Value()) ne 0 then begin
                
                    objref -> GetProperty, UValue = index
                    newval = objref -> Get_Value()
                    outputdat[index] = newval
                    output_hash[widget_uname] = outputdat
                
                endif
            
            end
            
            'string': begin
            
                if N_elements(objref -> Get_Value()) ne 0 then begin
                
                    output_hash[widget_uname] = objref -> Get_Value()
                
                endif
            
            end
            
            'droplist': begin
            
                output_hash[widget_uname] = event.str
            
            end
            
            'radiobuttons': begin
            
                widget_control, wid, GET_VALUE = button_name
                if event.select then output_hash[widget_uname] = button_name
                
            end
            
            'checkboxes': begin
            
                widget_control, wid, GET_UVALUE = button_index
                outputdat[button_index] = event.select
                output_hash[widget_uname] = outputdat
                
            end
            
        endcase

        ; print the modified data (for debug purposes)
        
        ; print, output_hash[widget_uname]
    
    endif


    ; handle events that originated from other widgets
    
    case widget_uname of

        'ok': begin

            ; the output data hash has already been updated
            
            formcancel = 0
            formclose = 1

        end

        'cancel': begin

            ; the output data hash has already been updated
            
            formcancel = 1
            formclose = 1

        end

        'page_select': begin
        
            if event_struct_name eq 'WIDGET_COMBOBOX' then begin
        
                ; the user has selected a new page - create a new set of 
                ; I/O widgets
                
                cb_wid = widget_info(event.top, $
                                     FIND_BY_UNAME='wmb_if_centerbase')
                
                bb_wid = widget_info(event.top, $
                                     FIND_BY_UNAME='wmb_if_buttonbase')
                
                widget_control, cb_wid, MAP=0
                widget_control, bb_wid, MAP=0
                
                ;widget_control, cb_wid, UPDATE=0
                
                pc_wid = widget_info(event.top, $
                                     FIND_BY_UNAME='wmb_if_pageiocontainer')
                
                pcgeo = widget_info(pc_wid, /GEOMETRY)
                
                ; create a widget in the centerbase to act as a place holder
                
                placeholder = widget_base(cb_wid, $
                                          xsize=pcgeo.xsize, $
                                          ysize=0, $
                                          map = 0, frame=0, space=0, xpad=0, $
                                          ypad=0)
                
                wid_children = widget_info(cb_wid, /ALL_CHILDREN)
                
                foreach val, wid_children do widget_control, val, map=0
                    

                foreach val, wid_children do begin
                
                    if val ne placeholder then widget_control, val, /destroy
                    
                endforeach
        
                pagelayout = layout_list[event.index]

                wmb_hash_display_form_build_io_widgets, pagelayout, $
                                                        cb_wid, $
                                                        wid_def_hash, $
                                                        output_hash, $
                                                        labelfont, $
                                                        fieldfont, $
                                                        rowframe
        
                wmb_hash_display_form_align_widgets, cb_wid, $
                                                     xpad=5, $
                                                     ypad=5, $
                                                     xspace = 5, $
                                                     yspace = rowyspace
        
                widget_control, placeholder, /destroy
        
                ;widget_control, cb_wid, UPDATE=1
        
                wait, 0.05D
        
                widget_control, cb_wid, MAP=1
                widget_control, bb_wid, MAP=1
        
            endif
        
        end

        else:

    endcase

    locinfo.cancel = formcancel

    ; save state information
    *locinfoptr = locinfo

    ; destroy the widget hierarchy
    if formclose then widget_control, event.top, /destroy

end


;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   Cleanup procedure
;
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

pro wmb_hash_display_form_cleanup, id

    compile_opt idl2, strictarrsubs
    
    ; get state information

    widget_control, id, get_uvalue=locinfoptr
    locinfo = *locinfoptr


end




;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   wmb_hash_display_form.pro
;
;   Main procedure
;
;   Note that a modal form widget is blocking (the No_block keyword is not 
;   specified to Xmanager) and "modal", meaning it is always on top, by 
;   specifying the modal keyword at the top level base.  A modal form widget
;   MUST have a group leader specified.
;
;   This procedure creates a table widget to display the contents of a hash.
;   The hash contents are not editable.
;
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


pro wmb_hash_display_form, grpleader, $
                           data_hash, $
                           wintitle = wtitle, $
                           datalabel = datalabel, $
                           labelfont = labelfont, $
                           fieldfont = fieldfont, $
                           yscroll = cb_yscroll
                           


    compile_opt idl2, strictarrsubs

    flag_autosize_cb = 0

    if N_elements(wtitle) eq 0 then wtitle = 'Data'
    if N_elements(labelfont) eq 0 then labelfont = ''
    if N_elements(fieldfont) eq 0 then fieldfont = ''
    if N_elements(cb_yscroll) eq 0 then flag_autosize_cb = 1


    if N_elements(grpleader) eq 0 then $
            message, 'Group leader must be specified'
            
    if N_elements(data_hash) eq 0 then $
            message, 'Data hash must be specified'



;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   Create widgets
;

    tlb = widget_base(column=1, title=wtitle, space=5, $
                      uname='tlb', xpad=5, ypad=5, $
                      /modal, /floating, GROUP_LEADER=grpleader, $
                      /base_align_center,  $
                      tlb_frame_attr = 1)



    ; create the center base to hold the table widget

    centerbase = widget_base(tlb, $
                             column=1, $
                             /base_align_center, $
                             xpad=0, $
                             ypad=5, $
                             uname='wmb_if_centerbase')
    
    ; extract the row labels from the input data hash
    
    nrows = data_hash.Count()
    
    if nrows eq 0 then message, 'Empty data hash'
    
    datalabels = (data_hash.Keys()).ToArray()
    
    ; convert the data hash to an array of structures
    ; (all data will first be converted to string type)
    
    tmp_dat = {labels:'',data:''}
    
    newstruct = {}
    
    for i = 0, nrows-1 do begin
    
        fieldnames[i] = 'field' + strtrim(string(i),2)    
        strdat[i] = wmb_converttostring(data_hash[rlabels[i]])
        
        newstruct = create_struct(newstruct,fieldnames[i],strdat[i])
        
    endfor
    
    datastruct = newstruct
    
    ; make the table
    
    table_id = widget_table(centerbase, $  
                            value=datastruct, $
                            font=fieldfont, $
                            column_labels = ['Value'], $
                            row_labels = rlabels, $
                            /COLUMN_MAJOR, $
                            scroll = 0, $
                            /ALL_EVENTS)

    ; Create the ok button

    bxsize = 60
    bysize = bxsize / 2.3
    bbase     = widget_base(tlb, row=1, space=5, /align_center, $
                            uname='wmb_if_buttonbase')
                            
    b_ok      = widget_button(bbase, value='OK', uname='ok', $
                              xsize=bxsize, ysize=bysize, $
                              ACCELERATOR='Return', font=labelfont)                          


    ; Center the top level base widget on display

    wmb_center_tlb_on_parent, tlb, grpleader

    Widget_Control, tlb, /Realize



;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   Create and store state information
;
;   This will be stored in the uvalue of the top level base
;

    local_info_struct = {cancel: 1                                }
               
               
    locinfoptr = ptr_new(local_info_struct)

    widget_control, tlb, set_uvalue=locinfoptr


;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   manage events (note the absence of a no_block keyword to xmanager)
;

    xmanager, 'wmb_hash_display_form', tlb, $
              cleanup='wmb_hash_display_form_cleanup', $
              event_handler='wmb_hash_display_form_event'


;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   The form has now been closed.  Return results to the calling program.
;

    result = *locinfoptr
    ptr_free, locinfoptr


end


;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   test program
;
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

pro hashformtest_event, event

    compile_opt idl2, strictarrsubs

    wintitle = 'Multi input dialog'

    inputdat = orderedhash()

    inputdat['First property aaaaaaaaaaaaaaaaaaaaaa'] = 1
    inputdat['Second property'] = [1,2]
    inputdat['Third property'] = 'This is a string'
    inputdat['Fourth property'] = 14.335
    inputdat['Fifth property'] = 092834L
    inputdat['Sixth property'] = [2.3,53.2,45.2]
    inputdat['Seventh property'] = list(3,4,5)
    inputdat['Eighth property'] = {First:1,Second:2}

    wmb_hash_display_form, event.top, $
                           inputdat, $
                           wintitle = wtitle
                           
    
end

pro hashformtest_cleanup, wid


end

pro hashformtest
   
    compile_opt idl2, strictarrsubs
    
    tlb = widget_base(col=1, space=10, xpad=50, ypad=50)

    bxsize = 60
    bysize = bxsize/2.3

    bbase     = widget_base(tlb, row=1, /align_center)
    b_ok      = widget_button(bbase, value='OK', uname='ok', $
                              xsize=bxsize, ysize=bysize, $
                              ACCELERATOR='Return')                          
          
    cgcentertlb, tlb   
    Widget_Control, tlb, /Realize
    XManager, 'hashformtest', tlb, /No_Block, CLEANUP = 'hashformtest_cleanup'
    
end





