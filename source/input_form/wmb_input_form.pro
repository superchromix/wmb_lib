;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   wmb_input_form.pro
;
;   Form widget to get a single numeric value from the user.
;
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc



;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   Event handler
;
;   Note that events generated by widgets other than the OK or Cancel buttons
;   are being ignored due to the case statement.
;
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


pro wmb_input_form_event, event

    compile_opt idl2, strictarrsubs

    formcancel = 0
    formclose = 0

    ; get state information
    widget_control, event.top, get_uvalue=locinfoptr
    locinfo = *locinfoptr

    ; retrieve information from the info pointer
    wid_def_hash = locinfo.wid_def_hash
    layout_list = locinfo.layout_list
    input_hash = locinfo.input_hash
    output_hash = locinfo.output_hash
    labelfont = locinfo.label_font
    fieldfont = locinfo.field_font
    rowframe = locinfo.row_frame
    rowyspace = locinfo.row_yspace

    ; identify widget which caused the event
    widget_uname = widget_info(event.id, /UNAME)

    event_struct_name = tag_names(event, /STRUCTURE_NAME)

    if event_struct_name eq 'FSC_INPUTFIELD_EVENT' then begin
    
        ; if the event came from an fsc_inputfield, then we need to use
        ; the object reference to talk to it
        
        objref = event.ObjRef
        objref -> GetProperty, Name = widget_uname
        
    endif

    ; if this event originated from one of the I/O widgets, handle it here
    
    if wid_def_hash.Haskey(widget_uname) then begin
    
        ; make sure the input and output hash also contain this key
        
        if ~input_hash.Haskey(widget_uname) then $
                                    message, 'Unmatched widget name'
                                    
        if ~output_hash.Haskey(widget_uname) then $
                                    message, 'Unmatched widget name'
                
        wid = event.id
        widdef = wid_def_hash[widget_uname]
        inputdat = input_hash[widget_uname]
        outputdat = output_hash[widget_uname]
                                    
        ; what kind of widget is this?
        
        wtype = widdef['type']
        
        case strlowcase(wtype) of
        
            'numeric': begin
            
                if N_elements(objref -> Get_Value()) ne 0 then begin
                
                    output_hash[widget_uname] = objref -> Get_Value()
                
                endif
            
            end
            
            'multinumeric': begin
            
                if N_elements(objref -> Get_Value()) ne 0 then begin
                
                    objref -> GetProperty, UValue = index
                    newval = objref -> Get_Value()
                    outputdat[index] = newval
                    output_hash[widget_uname] = outputdat
                
                endif
            
            end
            
            'string': begin
            
                if N_elements(objref -> Get_Value()) ne 0 then begin
                
                    output_hash[widget_uname] = objref -> Get_Value()
                
                endif
            
            end
            
            'droplist': begin
            
                output_hash[widget_uname] = event.str
            
            end
            
            'radiobuttons': begin
            
                widget_control, wid, GET_VALUE = button_name
                if event.select then output_hash[widget_uname] = button_name
                
            end
            
            'checkboxes': begin
            
                widget_control, wid, GET_UVALUE = button_index
                outputdat[button_index] = event.select
                output_hash[widget_uname] = outputdat
                
            end
            
        endcase

        ; print the modified data (for debug purposes)
        
        ; print, output_hash[widget_uname]
    
    endif


    ; handle events that originated from other widgets
    
    case widget_uname of

        'ok': begin

            ; the output data hash has already been updated
            
            formcancel = 0
            formclose = 1

        end

        'cancel': begin

            ; the output data hash has already been updated
            
            formcancel = 1
            formclose = 1

        end

        'page_select': begin
        
            if event_struct_name eq 'WIDGET_COMBOBOX' then begin
        
                ; the user has selected a new page - create a new set of 
                ; I/O widgets
                
                cb_wid = widget_info(event.top, $
                                     FIND_BY_UNAME='wmb_if_centerbase')
                
                bb_wid = widget_info(event.top, $
                                     FIND_BY_UNAME='wmb_if_buttonbase')
                
                widget_control, cb_wid, MAP=0
                widget_control, bb_wid, MAP=0
                
                ;widget_control, cb_wid, UPDATE=0
                
                pc_wid = widget_info(event.top, $
                                     FIND_BY_UNAME='wmb_if_pageiocontainer')
                
                pcgeo = widget_info(pc_wid, /GEOMETRY)
                
                ; create a widget in the centerbase to act as a place holder
                
                placeholder = widget_base(cb_wid, $
                                          xsize=pcgeo.xsize, $
                                          ysize=0, $
                                          map = 0, frame=0, space=0, xpad=0, $
                                          ypad=0)
                
                wid_children = widget_info(cb_wid, /ALL_CHILDREN)
                
                foreach val, wid_children do widget_control, val, map=0
                    

                foreach val, wid_children do begin
                
                    if val ne placeholder then widget_control, val, /destroy
                    
                endforeach
        
                pagelayout = layout_list[event.index]

                wmb_input_form_build_io_widgets, pagelayout, $
                                                        cb_wid, $
                                                        wid_def_hash, $
                                                        output_hash, $
                                                        labelfont, $
                                                        fieldfont, $
                                                        rowframe
        
                wmb_input_form_align_widgets, cb_wid, $
                                                     xpad=5, $
                                                     ypad=5, $
                                                     xspace = 5, $
                                                     yspace = rowyspace
        
                widget_control, placeholder, /destroy
        
                ;widget_control, cb_wid, UPDATE=1
        
                wait, 0.05D
        
                widget_control, cb_wid, MAP=1
                widget_control, bb_wid, MAP=1
        
            endif
        
        end

        else:

    endcase

    locinfo.cancel = formcancel

    ; save state information
    *locinfoptr = locinfo

    ; destroy the widget hierarchy
    if formclose then widget_control, event.top, /destroy

end


;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   Cleanup procedure
;
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

pro wmb_input_form_cleanup, id

    compile_opt idl2, strictarrsubs
    
    ; get state information

    widget_control, id, get_uvalue=locinfoptr
    locinfo = *locinfoptr


end


;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   wmb_input_form_align_widgets.pro
;
;   Align the I/O widgets within the base
;
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

pro wmb_input_form_align_widgets, centerbase, xpad=xpad, xspace=xspace, $
                                         ypad=ypad, yspace=yspace
             
    compile_opt idl2, strictarrsubs
                                         
    if N_elements(xpad) eq 0 then xpad=0
    if N_elements(ypad) eq 0 then ypad=0
    if N_elements(xspace) eq 0 then xspace=0
    if N_elements(yspace) eq 0 then yspace=0
    
    pageiocontainer = widget_info(centerbase, $
                                  FIND_BY_UNAME='wmb_if_pageiocontainer')
    
    widget_control, pageiocontainer, get_uvalue = page_infoptr
    
    n_columns = (*page_infoptr).n_columns
    
    wid_children = widget_info(pageiocontainer, /ALL_CHILDREN)
    
    ; nchildren is the number of rowcontainerbases contained in the
    ; pageiocontainer.  each rowcontainerbase contains one label and 
    ; one io widget.  when n_columns > 1, there are multiple rowcontainer
    ; bases per row.
    
    nchildren = N_elements(wid_children)
    
    ; how many rows are there?
    
    n_rows = ceil(long(nchildren) / long(n_columns))
    
    ; go through the child widgets to make a list of base widget unames
    ; and sizes
    
    wid_base_unames = strarr(n_columns,n_rows)
    
    label_wid_xsize = lonarr(n_columns,n_rows)
    label_wid_ysize = lonarr(n_columns,n_rows)
    
    io_wid_xsize = lonarr(n_columns,n_rows)
    io_wid_ysize = lonarr(n_columns,n_rows)
    
    for j = 0, n_columns-1 do begin
    
        rowindex = 0
    
        for i = j, nchildren-1, n_columns do begin
        
            ; the pageiocontainer contains the rowcontainerbases, which each 
            ; contain two bases: one for the label and one for the I/O widget
        
            wid_uname = widget_info(wid_children[i], /UNAME)
            
            isrowbase = strpos(wid_uname, '_rowcontainer') ne -1
            
            if ~ isrowbase then message, 'Unexpected widget encountered'
            
            
            ; get information about the label base
            
            basename = strmid(wid_uname, 0,  strpos(wid_uname, '_rowcontainer'))
            
            wid_base_unames[j,rowindex] = basename
            
            label_uname = basename + '_labelbase'
            
            labelbase = widget_info(wid_children[i], FIND_BY_UNAME=label_uname)
            
            if labelbase ne 0 then begin
            
                wgeo = widget_info(labelbase, /GEOMETRY)
                xsize_label = wgeo.xsize
                ysize_label = wgeo.ysize
                
                label_wid_xsize[j,rowindex] = xsize_label
                label_wid_ysize[j,rowindex] = ysize_label
                
            endif else message, 'Label base not found'
            
            
            ; get information about the I/O base
            
            io_uname = basename + '_iobase'
            
            iobase = widget_info(wid_children[i], FIND_BY_UNAME=io_uname)
            
            if iobase ne 0 then begin
            
                wgeo = widget_info(iobase, /GEOMETRY)
                xsize_io = wgeo.xsize
                ysize_io = wgeo.ysize
                
                io_wid_xsize[j,rowindex] = xsize_io
                io_wid_ysize[j,rowindex] = ysize_io
                
            endif else message, 'I/O base not found'
            
            rowindex = rowindex + 1
            
        endfor
    endfor
    
    ; get the maximum x size of the labels and io bases for each column
    
    max_xsize_label_by_col = max(label_wid_xsize, dimension=2)
    max_ysize_label_by_row = max(label_wid_ysize, dimension=1)
    
    max_xsize_io_by_col = max(io_wid_xsize, dimension=2)
    max_ysize_io_by_row = max(io_wid_ysize, dimension=1)
    
    
    ; calculate the left edge positions for the row bases of each
    ; column, and for the io widgets within each column
        
    rowbase_col_xoffset = lonarr(n_columns)
    io_col_xoffset = lonarr(n_columns)
        
    rowbase_col_xoffset[0] = xpad
    
    io_col_xoffset[0] = max_xsize_label_by_col[0] + xspace
       
    if n_columns gt 1 then begin
       
        for i = 1, n_columns-1 do begin
            
            rowbase_col_xoffset[i] = rowbase_col_xoffset[i-1] + $
                                     io_col_xoffset[i-1] + $
                                     max_xsize_io_by_col[i-1] + $
                                     xspace
                                   
            io_col_xoffset[i] = max_xsize_label_by_col[i] + $
                                xspace

        endfor    
        
    endif
    
    
    ; calculate the yoffset for each element
    
    rowbase_yoffset = lonarr(n_columns, n_rows)
    label_yoffset = lonarr(n_columns, n_rows)
    io_yoffset = lonarr(n_columns, n_rows)
    
    current_ypos = ypad
    
    for i = 0, n_rows-1 do begin
       
        rowbase_yoffset[*,i] = current_ypos
       
        label_max_ysize = max_ysize_label_by_row[i]
        io_max_ysize = max_ysize_io_by_row[i]
        
        element_max_ysize = label_max_ysize > io_max_ysize
       
        for j = 0, n_columns-1 do begin
            
            label_ysize = label_wid_ysize[j,i]
            io_ysize = io_wid_ysize[j,i]

            label_yoffset[j,i] = abs((label_ysize-element_max_ysize) / 2.0)
            
            io_yoffset[j,i] = abs((io_ysize - element_max_ysize) / 2.0)
                              
        endfor    
        
        current_ypos = current_ypos + element_max_ysize
        
    endfor
    
    
    ; place the objects
    
    for i = 0, n_rows-1 do begin
       
        for j = 0, n_columns-1 do begin
    
            basename = wid_base_unames[j,i]
    
            rowbasename = basename + '_rowcontainer'
            ioname = basename + '_iobase'
            labelname = basename + '_labelbase'
         
            rowbasewid = widget_info(pageiocontainer, FIND_BY_UNAME=rowbasename)
            labelbasewid = widget_info(pageiocontainer, FIND_BY_UNAME=labelname)
            iobasewid = widget_info(pageiocontainer, FIND_BY_UNAME=ioname)
    
            if labelbasewid eq 0 then message, 'Unmatched label widget'
            if iobasewid eq 0 then message, 'Unmatched label widget'
            if rowbasewid eq 0 then message, 'Unmatched label widget'
        

            tmp_label_xoffset = 0
            tmp_label_yoffset = label_yoffset[j,i]

            widget_control, labelbasewid, xoffset = tmp_label_xoffset, $
                                          yoffset = tmp_label_yoffset
        
            tmp_io_xoffset = io_col_xoffset[j]
            tmp_io_yoffset = io_yoffset[j,i]
        
            widget_control, iobasewid, xoffset = tmp_io_xoffset, $
                                       yoffset = tmp_io_yoffset
    
            tmp_rowbase_xoffset = rowbase_col_xoffset[j]
            tmp_rowbase_yoffset = rowbase_yoffset[j,i]
    
            widget_control, rowbasewid, xoffset = tmp_rowbase_xoffset, $
                                        yoffset = tmp_rowbase_yoffset, $
                                        map = 1
    
        endfor
        
    endfor

end

;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   wmb_input_form_createwidget.pro
;
;   Build a single page widget
;
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

pro wmb_input_form_createwidget, widgetdef, inputdata, $
                                 containerbase, labelfont, fieldfont, $
                                 rowframe, uname_base
    
    compile_opt idl2, strictarrsubs
    
    if N_elements(create_label) eq 0 then create_label=0
    
    ; create a base to hold a the label and the I/O widget
    
    tmpuname = uname_base + '_rowcontainer'
    
    rowcontainerbase = widget_base(containerbase, frame=rowframe, $
                                   uname=tmpuname, map = 0)
    
    tmpuname = uname_base + '_labelbase'
    
    labelcolbase = widget_base(rowcontainerbase, column=1, space=0, $
                               /base_align_left, frame=0, $
                               uname=tmpuname)

    tmpuname = uname_base + '_iobase'

    iorowbase = widget_base(rowcontainerbase, row=1, space=5, $
                            /base_align_center, frame=0, $
                            uname=tmpuname)

    if ~ widgetdef.Haskey('type') then message, 'Missing widget type'
    
    if ~ widgetdef.Haskey('label') then wlabel = '' else $
                                        wlabel = widgetdef['label']
                                        
    if ~ widgetdef.Haskey('prefixlabel') then prelabel = '' else $
                                prelabel = widgetdef['prefixlabel']
                                        
    if ~ widgetdef.Haskey('postfixlabel') then postlabel = '' else $
                                postlabel = widgetdef['postfixlabel']
    
    if N_elements(wlabel) gt 1 then begin
    
        ; this is a multiline label
        foreach str, wlabel do $
            wid_wlabel = widget_label(labelcolbase, value=str, font=labelfont)
            
    endif else begin
    
        wid_wlabel = widget_label(labelcolbase, value=wlabel, font=labelfont)
        
    endelse

    ; what kind of widget is it?
    wtype = strlowcase(widgetdef['type'])

    case wtype of
    
        'numeric' : begin
        
            if ~ widgetdef.Haskey('integertype') then integertype = 0 else $
                                        integertype = widgetdef['integertype']
                                                
            doubletype = ~integertype
            
            inputtype = size(inputdata, /type)
            
            if doubletype then begin
                
                ; if the input value is not a double, convert it to double 
                ; in a way that doesn't add additional digits in the 
                ; decimal places
                
                if inputtype ne 5 then begin
                    tmpstr = string(inputdata)
                    inputdata = double(tmpstr) 
                endif
            
            endif else begin
            
                inputdata=long(inputdata)
        
            endelse
        
            if inputdata eq 0 then logscale = 0 $
                              else logscale = alog10(abs(inputdata))
            
            dec_digits = 0
            if doubletype then dec_digits = 3
            if logscale lt 0 then dec_digits = dec_digits + abs(round(logscale))
            
            std_digits = dec_digits + 4
            if logscale gt 0 then std_digits = std_digits + abs(round(logscale))
                
            if ~ widgetdef.Haskey('xsize') then xsize = std_digits else $
                                                xsize = widgetdef['xsize']
       
       
            oinput   = fsc_inputfield(iorowbase, Title=prelabel, $
                                      Value=inputdata, $
                                      Longvalue=integertype, $
                                      Doublevalue=doubletype,$
                                      Decimal = dec_digits, $
                                      Xsize=xsize, $
                                      Fieldfont=fieldfont, $
                                      Name=uname_base, $
                                      Event_pro='wmb_input_form_event')

        end
        
        
        'multinumeric' : begin
        
            if ~ widgetdef.Haskey('deflist') then $
                    message, 'Missing widget definition list for multinumeric'
        
            nwid = N_elements(widgetdef['deflist'])
            
            if nwid ne N_elements(inputdata) then $
                    message, 'Input data does not match multinumeric definition'
            
            foreach wdef, widgetdef['deflist'], index do begin 

                if ~ wdef.Haskey('integertype') then integertype = 0 else $
                                          integertype = wdef['integertype']

                indat = inputdata[index]

                doubletype = ~integertype
                
                inputtype = size(indat, /type)
                
                if doubletype then begin
                    
                    ; if the input value is not a double, convert it to double 
                    ; in a way that doesn't add additional digits in the 
                    ; decimal places
                    
                    if inputtype ne 5 then begin
                        tmpstr = string(indat)
                        indat = double(tmpstr) 
                    endif
                
                endif else begin
                
                    indat=long(indat)
            
                endelse
            
                if indat eq 0 then logscale = 0 $
                              else logscale = alog10(abs(indat))
                
                dec_digits = 0
                if doubletype then dec_digits = 3
                if logscale lt 0 then dec_digits = dec_digits $
                                                   + abs(round(logscale))
                
                std_digits = dec_digits + 4
                if logscale gt 0 then std_digits = std_digits $
                                                   + abs(round(logscale))
                    
                if ~ wdef.Haskey('xsize') then xsize = std_digits $
                                          else xsize = wdef['xsize']
           
                if ~ wdef.Haskey('label') then tmplbl = '' $
                                          else tmplbl = wdef['label']

                if N_elements(tmplbl) gt 1 then tmplbl = tmplbl[0]
           
                if ~ wdef.Haskey('postfixlabel') then plabel = '' else $
                                           plabel = wdef['postfixlabel']
           
                ; store the index of this entry in the multinumeric widget
                ; in the UValue of the object
           
                oinput   = fsc_inputfield(iorowbase, Title=tmplbl, $
                                      Value=indat, $
                                      Longvalue=integertype, $
                                      Doublevalue=doubletype,$
                                      Decimal = dec_digits, $
                                      Xsize=xsize, $
                                      Fieldfont=fieldfont, $
                                      Labelalign=1, $
                                      Labelfont=fieldfont, $
                                      Name=uname_base, $
                                      UValue = index, $
                                      Event_pro='wmb_input_form_event')
    
                if plabel ne '' then postlabelwid = widget_label(iorowbase, $
                                                              value=plabel, $
                                                              font=fieldfont) 
    
            endforeach
            
        end
        
        
        'string' : begin
                             
            if ~ widgetdef.Haskey('xsize') then tmpxsize = 24 else $
                                                tmpxsize = widgetdef['xsize']
              
            tmpxsize = tmpxsize > strlen(inputdata)
            
            oinput   = fsc_inputfield(iorowbase, Title=prelabel, $
                                      Value=inputdata, $
                                      Xsize=tmpxsize, $
                                      Fieldfont=fieldfont, $
                                      Name=uname_base, $
                                      Event_pro='wmb_input_form_event')

        end
        
        
        'droplist' : begin
        
            if ~ widgetdef.Haskey('droplist') then begin
            
                message, 'Droplist strings must be specified'
                
            endif else begin
            
                tmpdl = widgetdef['droplist']
                
            endelse
        
            wid_input = widget_combobox(iorowbase, value=tmpdl, $
                                        uname=uname_base, $
                                        font=fieldfont, $
                                        ysize=25, $
                                        event_pro='wmb_input_form_event')
                                     
            tmpinput = strlowcase(inputdata)
            lc_tmpdl = strlowcase(tmpdl)
            indarr = where(tmpinput eq lc_tmpdl, tmpcnt)
            
            if tmpcnt gt 0 then tmpindex = indarr[0] else $
                                tmpindex = 0
                                        
            widget_control, wid_input, SET_COMBOBOX_SELECT = tmpindex

        end
        
        
        'radiobuttons' : begin
        
            if ~ widgetdef.Haskey('radiobuttons') then begin
            
                message, 'Radiobutton strings must be specified'
                
            endif else begin
            
                tmprb = widgetdef['radiobuttons']
                
            endelse
    
            if ~ widgetdef.Haskey('vertical') then chk_vertical = 0 else $
                                           chk_vertical = widgetdef['vertical']
    
            if ~ widgetdef.Haskey('buttonspacing') then bspacing = 0 else $
                                          bspacing = widgetdef['buttonspacing']
    
            if chk_vertical eq 0 then begin
    
                buttonbase = widget_base(iorowbase, row=1, space=bspacing, $
                                         /exclusive)
                                         
            endif else begin
            
                buttonbase = widget_base(iorowbase, column=1, space=bspacing, $
                                         /exclusive)
            
            endelse
                                            
            nbuttons = N_elements(tmprb)
            
            tmpbuttons = strlowcase(tmprb)
            tmpinput = strlowcase(inputdata)
            inputindex = where(tmpinput eq tmpbuttons, tmpcnt)
            
            if tmpcnt ne 1 then $
               message, 'Radiobutton input data does not match button list'
            

            for i = 0, nbuttons-1 do begin

                ; store the button number in the uvalue of the button

                rbutton = widget_button(buttonbase, value=tmprb[i], $
                                     event_pro='wmb_input_form_event', $
                                     uname=uname_base, $
                                     font=fieldfont)
            
                widget_control, rbutton, SET_BUTTON = (i eq inputindex)
            
            endfor
        
        end
        
        
        'checkboxes' : begin
        
            if ~ widgetdef.Haskey('checkboxes') then begin
            
                message, 'Checkbox strings must be specified'
                
            endif else begin
            
                cbstr = widgetdef['checkboxes']
                
            endelse
     
            if ~ widgetdef.Haskey('vertical') then chk_vertical = 0 else $
                                           chk_vertical = widgetdef['vertical']
    
            if ~ widgetdef.Haskey('buttonspacing') then bspacing = 0 else $
                                          bspacing = widgetdef['buttonspacing']
     
            if chk_vertical eq 0 then begin
     
                buttonbase = widget_base(iorowbase, row=1, space=bspacing, $
                                         /nonexclusive)
                                         
            endif else begin
            
                buttonbase = widget_base(iorowbase, column=1, space=bspacing, $
                                         /nonexclusive)
            
            endelse
                                        
            nbuttons = N_elements(cbstr)
            
            n_input = N_elements(inputdata)
            
            if nbuttons ne n_input then $
                message, 'Number of inputs does not equal number of checkboxes'
            
            for i = 0, nbuttons-1 do begin

                ; store the button number in the uvalue of the button
                                       
                rbutton = widget_button(buttonbase, value=cbstr[i], $
                                     uname=uname_base, $
                                     uvalue=i, $
                                     event_pro='wmb_input_form_event', $
                                     font=fieldfont)
            
                if inputdata[i] then widget_control, rbutton, /SET_BUTTON
            
            endfor

        end
    
    endcase

    if postlabel ne '' then postlabelwid = widget_label(iorowbase, $
                                                        value=postlabel, $
                                                        font=fieldfont) 

end


;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   wmb_input_form_build_io_widgets.pro
;
;   Build a single page of widgets based on a pagelayout structure
;
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

pro wmb_input_form_build_io_widgets, pagelayout, containerbase, $
                                     widget_definition_hash, $
                                     input_hash, $
                                     labelfont, fieldfont, rowframe

    compile_opt idl2, strictarrsubs

    desclabel = pagelayout.description

    n_columns = 1 > pagelayout.n_columns

    ; create base to hold the description label

    if desclabel ne '' then begin

        descbase = widget_base(containerbase, row=1, $
                               /base_align_center)
                               
        labelwid = widget_label(descbase, value=desclabel, font=labelfont)
        
    endif

    ; store the number of columns in the pageiocontainer base widget's uvalue

    pageiocontainer_info = {n_columns:n_columns}
    pageiocontainer_infoptr = ptr_new(pageiocontainer_info)

    pageiocontainer = widget_base(containerbase, $
                                  uname='wmb_if_pageiocontainer', $
                                  uvalue=pageiocontainer_infoptr)
        

    wkeys = pagelayout.widget_key_list

    nwidgets = N_elements(wkeys)
    
    ; check for missing values in the hashes
    
    foreach val, wkeys do begin
    
        if ~ widget_definition_hash.Haskey(val) then $
                message, 'Missing widget definition'
                
        if ~ input_hash.Haskey(val) then $
                message, 'Missing value in input hash'
                
    endforeach
               
               
    ; create the io widgets
    
    foreach val, wkeys do begin

        wdef = widget_definition_hash[val]
        tmpinput = input_hash[val]

        wmb_input_form_createwidget, wdef, tmpinput, $
                                            pageiocontainer, labelfont, $
                                            fieldfont, rowframe, val 
                                            
    endforeach


end




;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   wmb_input_form.pro
;
;   Main procedure
;
;   Note that a modal form widget is blocking (the No_block keyword is not 
;   specified to Xmanager) and "modal", meaning it is always on top, by 
;   specifying the modal keyword at the top level base.  A modal form widget
;   MUST have a group leader specified.
;
;   The I/O widgets are defined by a hash of hashes.  For each entry in the top
;   level hash, its key is a string which specifies a unique name describing
;   the data handled by that widget.  Each entry in the hash contains another
;   hash, which contains information defining the widget.
;   
;   The input and output data are held in two hashes.  Again the same key
;   names are used to associate the input and output data with their respective
;   widgets.
;   
;   The layout of the widgets, how they are grouped into separate pages and
;   how they are arranged on each page, is defined by a list of structures.  
;   Each structure defines one page of the widget.  The structure consists
;   of a string, defining the page title, and a list of strings corresponding
;   to the widget key names.
;   
;   The widgets are arranged in a form interface, in one ore more columns.  
;   At the bottom of the form there are OK and Cancel buttons.  When the 
;   widget is closed it returns with output data entries updated.
;   
;   When there are more than one column, the widgets are filled into the
;   form row by row.
;   
;   The widgets are organized into separate "pages" which are accessed 
;   via a dropdown list at the top of the window.
;   
;
;   Format for the widget definition hash:
;   
;       type:       'Numeric'      : a numeric entry field
;                   'String'       : a string entry field
;                   'Droplist'     : a dropdown list
;                   'Radiobuttons' : a row of radio buttons (exclusive, min 2)
;                   'Vertical_Radiobuttons: a column of radio buttons 
;                   'Checkboxes'   : a row of checkboxes (nonexclusive, min 1)
;                   'MultiNumeric' : multiple numeric entries on the same line
;       
;       
;       additional fields for 'Numeric' type:
;       
;       xsize:          the size of the input field in characters
;       integertype:    a flag indicating an integer value
;       label:          a label string describing the value OR
;                       an array of strings (for a multiline label)
;       prefixlabel:    a label which immediately precedes the input field
;       postfixlabel:   a label which follows the input field
;       
;       format for input and output hash for 'Numeric' type:
;       
;       input:          a numeric input value
;       output:         a numeric output value
;       
;       
;       additional fields for 'MultiNumeric' type:
;       
;       deflist:        a list of hashes defining single numeric entries
;                       (note that the labels for each numeric may only 
;                        be single line)
;       label:          a label string describing the value OR
;                       an array of strings (for a multiline label)
;       postfixlabel:   a label which follows the input field
;       
;       format for input and output hash for 'MultiNumeric' type:
;       
;       input:          an array of numeric input values
;       output:         an array of numeric output values
;       
;       
;       additional fields for 'String' type:
;       
;       xsize:          the size of the input field in characters
;       label:          a label string describing the value OR
;                       an array of strings (for a multiline label)
;       prefixlabel:    a label which immediately precedes the input field
;       postfixlabel:   a label which follows the input field
;       
;       format for input and output hash for 'String' type:
;       
;       input:          a string
;       output:         a string
;       
;       
;       additional fields for 'Droplist' type:
;       
;       droplist:       an array of strings defining the droplist entries
;       label:          a label string describing the value OR
;                       an array of strings (for a multiline label)
;       postfixlabel:   a label which follows the droplist on the right
;       
;       format for input and output hash for 'Droplist' type:
;       
;       input:          a string equal to the selected entry in the droplist
;       output:         a string equal to the selected entry in the droplist
;       
;       
;       additional fields for 'Radiobuttons' type:
;       
;       radiobuttons:   an array of strings describing the radio buttons
;       buttonspacing:  how much horizontal space (in pixels) to leave
;                       between buttons
;       label:          a label string describing the value OR
;                       an array of strings (for a multiline label)
;       postfixlabel:   a label which follows the radiobutton group on the right
;       vertical:       a flag (0 or 1) indicating whether the buttons should
;                       be arranged vertically
;       
;       format for input and output hash for 'Radiobuttons' type:
;       
;       input:          a string equal to the selected radiobutton 
;       output:         a string equal to the selected radiobutton
;                       
;       
;       additional fields for 'Checkboxes' type:
;        
;       checkboxes:     an array of strings describing the checkboxes
;       buttonspacing:  how much horizontal space (in pixels) to leave
;                       between buttons
;       label:          a label string describing the value OR
;                       an array of strings (for a multiline label)
;       postfixlabel:   a label which follows the checkbox group on the right
;       vertical:       a flag (0 or 1) indicating whether the buttons should
;                       be arranged vertically
;
;       format for input and output hash for 'Checkboxes' type:
;       
;       input:          an array of ones and zeros indicating the box states
;       output:         an array of ones and zeros indicating the box states
;
;
;   Format for the layout list:
;   
;   {wmb_input_form_layout, page_title:'', $
;                           description:'', $
;                           n_columns:0, $
;                           widget_key_list:list()}
;
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc


pro wmb_input_form, grpleader, $
                    widget_definition_hash, $
                    layout_list, $
                    data_hash, $
                    formcancel, $
                    wintitle = wtitle, $
                    labelfont = labelfont, $
                    fieldfont = fieldfont, $
                    yscroll = cb_yscroll, $
                    frame = rowframe, $
                    yspace = rowyspace
                           


    compile_opt idl2, strictarrsubs

    flag_autosize_cb = 0

    if N_elements(wtitle) eq 0 then wtitle = 'Input form'
    if N_elements(labelfont) eq 0 then labelfont = ''
    if N_elements(fieldfont) eq 0 then fieldfont = ''
    if N_elements(cb_yscroll) eq 0 then flag_autosize_cb = 1
    if N_elements(rowframe) eq 0 then rowframe = 0
    if N_elements(rowyspace) eq 0 then rowyspace = 0


    if N_elements(grpleader) eq 0 then $
            message, 'Group leader must be specified'
            
    if N_elements(widget_definition_hash) eq 0 then $
            message, 'Widget definition list must be specified'
            
    if N_elements(layout_list) eq 0 then $
            message, 'Layout list must be specified'
            
    if N_elements(data_hash) eq 0 then $
            message, 'Data hash must be specified'


    

;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   Create two hashes to store the input data and the output data
;

    input_hash = data_hash[*]
    output_hash = data_hash[*]

;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   Create widgets
;

    tlb = widget_base(column=1, title=wtitle, space=5, $
                      uname='tlb', xpad=5, ypad=5, $
                      /modal, /floating, GROUP_LEADER=grpleader, $
                      /base_align_center,  $
                      tlb_frame_attr = 1)


    ; Create the dropdown list for page selection
    
    npages = N_elements(layout_list)
    page_names = (layout_list.toarray()).page_title

    if npages gt 1 then begin

        basewid = widget_base(tlb, row=1, space=0, ypad=0, $
                              frame=0, /base_align_center)
    
        ; tmptxt = 'Page select: '
        ; labelwid = widget_label(basewid, value=tmptxt, font=labelfont)
    
        wid_page_select = widget_combobox(basewid, $ 
                                          value=page_names, $
                                          uname='page_select', $
                                          font=fieldfont, ysize=25)
                                          
        widget_control, wid_page_select, SET_COMBOBOX_SELECT=0

    endif


    ; create the center base to hold I/O widgets

    if flag_autosize_cb then begin
    
        centerbase = widget_base(tlb, $
                                 column=1, $
                                 /base_align_center, $
                                 xpad=0, $
                                 ypad=5, $
                                 frame = (npages gt 1), $
                                 uname='wmb_if_centerbase')
    
    endif else begin
    
        centerbase = widget_base(tlb, $
                                 column=1, $
                                 /base_align_center, $
                                 xpad=0, $
                                 ypad=5, $
                                 frame = (npages gt 1), $
                                 uname='wmb_if_centerbase', $
                                 y_scroll_size=cb_yscroll )

    endelse



    pagelayout = layout_list[0]


    wmb_input_form_build_io_widgets, pagelayout, centerbase, $
                                            widget_definition_hash, $
                                            output_hash, $
                                            labelfont, fieldfont, $
                                            rowframe
    


;   Create ok and cancel buttons

    bxsize = 60
    bysize = bxsize / 2.3
    bbase     = widget_base(tlb, row=1, space=5, /align_center, $
                            uname='wmb_if_buttonbase')
                            
    b_ok      = widget_button(bbase, value='OK', uname='ok', $
                              xsize=bxsize, ysize=bysize, $
                              ACCELERATOR='Return', font=labelfont)                          
    b_cancel  = widget_button(bbase, value='Cancel', uname='cancel', $
                              xsize=bxsize, ysize=bysize, font=labelfont)


    ; Center the top level base widget on display

    wmb_center_tlb_on_parent, tlb, grpleader

    Widget_Control, tlb, /Realize


    ; Align the widgets into ordered columns

    wmb_input_form_align_widgets, centerbase, xpad=5, ypad=5, $
                                  xspace = 5, yspace = rowyspace


;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   Create and store state information
;
;   This will be stored in the uvalue of the top level base
;

    local_info_struct = {wid_def_hash:    widget_definition_hash, $
                         layout_list:     layout_list, $
                         input_hash:      input_hash, $
                         output_hash:     output_hash, $ 
                         label_font:      labelfont, $
                         field_font:      fieldfont, $
                         row_frame:       rowframe, $
                         row_yspace:      rowyspace, $
                         cancel: 1                                }
               
               
    locinfoptr = ptr_new(local_info_struct)

    widget_control, tlb, set_uvalue=locinfoptr


;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   manage events (note the absence of a no_block keyword to xmanager)
;

    xmanager, 'wmb_input_form', tlb, $
              cleanup='wmb_input_form_cleanup', $
              event_handler='wmb_input_form_event'


;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   The form has now been closed.  Return results to the calling program.
;

    result = *locinfoptr
    ptr_free, locinfoptr

    output_hash = result.output_hash
    formcancel = result.cancel

    obj_destroy, data_hash

    if formcancel then data_hash = input_hash[*] $
                  else data_hash = output_hash[*]
    
    obj_destroy, input_hash
    obj_destroy, output_hash
    
end


;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
;
;   test program
;
;ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

pro inputformtest_event, event

    compile_opt idl2, strictarrsubs

    wintitle = 'Multi input dialog'
    ; labelfont = 'Courier New*16'
    ; fieldfont = 'Courier New*16'
    ; labelfont = 'Segoe UI*16'
    ; fieldfont = 'Segoe UI*16'
    labelfont = 'Verdana*14'
    fieldfont = 'Verdana*14'
    ; labelfont = 'Tahoma*16'
    ; fieldfont = 'Tahoma*16'
    ; labelfont = 'Arial*17'
    ; fieldfont = 'Arial*17'
    
    def_int1 = hash()
    def_int1['type'] = 'numeric'
    def_int1['integertype'] = 1
    def_int1['label'] = 'Test integer'
    def_int1['postfixlabel'] = 'nm'
    
    def_str1 = hash()
    def_str1['type'] = 'string'
    def_str1['xsize'] = 20
    def_str1['label'] = 'Test string'
    def_str1['postfixlabel'] = 'nm'
    
    def_flt1 = hash()
    def_flt1['type'] = 'numeric'
    def_flt1['integertype'] = 0
    def_flt1['label'] = ['Test float','(multiline label)']
    def_flt1['postfixlabel'] = 'nm'

    dlstrings = ['first','second','third']
    def_dl1 = hash()
    def_dl1['type'] = 'droplist'
    def_dl1['droplist'] = dlstrings
    def_dl1['label'] = 'Test droplist'
    
    rbstrings = ['first','second','third']
    def_rb1 = hash()
    def_rb1['type'] = 'radiobuttons'
    def_rb1['radiobuttons'] = rbstrings
    def_rb1['buttonspacing'] = 0
    def_rb1['label'] = 'Test radiobuttons'

    vrbstrings = ['first','second','third']
    def_vrb1 = hash()
    def_vrb1['type'] = 'radiobuttons'
    def_vrb1['radiobuttons'] = vrbstrings
    def_vrb1['buttonspacing'] = 0
    def_vrb1['vertical'] = 1
    def_vrb1['label'] = ['Test vertical', 'radiobuttons']

    cbstrings = ['first','second','third']
    def_cb1 = hash()
    def_cb1['type'] = 'checkboxes'
    def_cb1['checkboxes'] = cbstrings
    def_cb1['buttonspacing'] = 0
    def_cb1['label'] = 'Test checkboxes'

    def_intmax = hash()
    def_intmax['type'] = 'numeric'
    def_intmax['integertype'] = 1
    def_intmax['label'] = 'max'
    def_intmax['postfixlabel'] = ''
    
    def_intmin = hash()
    def_intmin['type'] = 'numeric'
    def_intmin['integertype'] = 1
    def_intmin['label'] = 'min'
    def_intmin['postfixlabel'] = ''
    
    def_multinumeric1 = hash()
    def_multinumeric1['type'] = 'multinumeric'
    def_multinumeric1['deflist'] = list(def_intmax, def_intmin)
    def_multinumeric1['label'] = 'Test multinumeric'
    def_multinumeric1['postfixlabel'] = 'nm'

    def_int1a = hash()
    def_int1a['type'] = 'numeric'
    def_int1a['integertype'] = 1
    def_int1a['label'] = 'Test integer'
    def_int1a['postfixlabel'] = 'nm'
    
    def_str1a = hash()
    def_str1a['type'] = 'string'
    def_str1a['xsize'] = 20
    def_str1a['label'] = 'Test string'
    def_str1a['postfixlabel'] = 'nm'
    
    def_flt1a = hash()
    def_flt1a['type'] = 'numeric'
    def_flt1a['integertype'] = 0
    def_flt1a['label'] = ['Test float','(multiline label)']
    def_flt1a['postfixlabel'] = 'nm'
    
    def_int1b = hash()
    def_int1b['type'] = 'numeric'
    def_int1b['integertype'] = 1
    def_int1b['label'] = 'Test integer'
    def_int1b['postfixlabel'] = 'nm'
    
    def_str1b = hash()
    def_str1b['type'] = 'string'
    def_str1b['xsize'] = 20
    def_str1b['label'] = 'Test string'
    def_str1b['postfixlabel'] = 'nm'
    
    def_flt1b = hash()
    def_flt1b['type'] = 'numeric'
    def_flt1b['integertype'] = 0
    def_flt1b['label'] = ['Test float','(multiline label)']
    def_flt1b['postfixlabel'] = 'nm'
    
    wkeynames = ['testint1', $
                 'testflt1', $
                 'testdl1', $
                 'testdl2', $
                 'testrb1', $
                 'testcb1', $
                 'teststr1', $
                 'testmn1', $
                 'testvrb1', $
                 'testint1a', $
                 'testflt1a', $
                 'teststr1a', $
                 'testint1b', $
                 'testflt1b', $
                 'teststr1b']
                 
    wdef = orderedhash()
    wdef[wkeynames] = [def_int1, def_flt1, def_dl1, def_dl1, $
                       def_rb1, def_cb1, def_str1, def_multinumeric1, $
                       def_vrb1, def_int1a, def_flt1a, def_str1a, $
                       def_int1b, def_flt1b, def_str1b]
                       
    inputdat = hash()
    inputdat[wkeynames[0]] = 1
    inputdat[wkeynames[1]] = 1.0
    inputdat[wkeynames[2]] = 'first'
    inputdat[wkeynames[3]] = 'first'
    inputdat[wkeynames[4]] = 'first'
    inputdat[wkeynames[5]] = [1, 0, 0]
    inputdat[wkeynames[6]] = 'widget test first'
    inputdat[wkeynames[7]] = [1, 1]
    inputdat[wkeynames[8]] = 'first'
    inputdat[wkeynames[9]] = 1
    inputdat[wkeynames[10]] = 1.0
    inputdat[wkeynames[11]] = 'first'
    inputdat[wkeynames[12]] = 1
    inputdat[wkeynames[13]] = 1.0
    inputdat[wkeynames[14]] = 'first'
    
    
    layout_pg1 = {wmb_input_form_layout}
    layout_pg1.page_title = 'Test this widget page 1'
    layout_pg1.description = 'Here are some input widgets'
    wklist1 = list('testflt1','testint1','testmn1','testrb1','testcb1',$
                   'teststr1', 'testvrb1')
    layout_pg1.widget_key_list = wklist1
    
    layout_pg2 = {wmb_input_form_layout}
    layout_pg2.page_title = 'This is page 2'
    layout_pg2.description = 'Here are MORE widgets'
    wklist2 = list('testdl1', 'testdl2')
    layout_pg2.widget_key_list = wklist2
    
    layout_pg3 = {wmb_input_form_layout}
    layout_pg3.page_title = 'This is page 3'
    layout_pg3.description = 'Here are two columns of widgets'
    layout_pg3.n_columns = 2
    wklist3 = list('testint1a','testint1b','testflt1a','testflt1b','teststr1a','teststr1b')
    layout_pg3.widget_key_list = wklist3
    
    
    
    ; layoutlist = list(layout_pg1)
    layoutlist = list(layout_pg1,layout_pg2,layout_pg3)

    print, inputdat

    wmb_input_form, event.top, $
                           wdef, $
                           layoutlist, $
                           inputdat, $
                           formcancel, $
                           wintitle = wtitle, $
                           labelfont = labelfont, $
                           fieldfont = fieldfont, $
                           yscroll = 200, $
                           frame=1
                           
    print, inputdat
    
end

pro inputformtest_cleanup, wid


end

pro inputformtest
   
    compile_opt idl2, strictarrsubs
    
    tlb = widget_base(col=1, space=10, xpad=50, ypad=50)

    bxsize = 60
    bysize = bxsize/2.3

    bbase     = widget_base(tlb, row=1, /align_center)
    b_ok      = widget_button(bbase, value='OK', uname='ok', $
                              xsize=bxsize, ysize=bysize, $
                              ACCELERATOR='Return')                          
          
    cgcentertlb, tlb   
    Widget_Control, tlb, /Realize
    XManager, 'inputformtest', tlb, /No_Block, CLEANUP = 'inputformtest_cleanup'
    
end





